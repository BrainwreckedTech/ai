#!/usr/bin/env bash

source "${0%/*}/ai-funcs"

################################################################################
# Here are more global variables to share amongst functions
################################################################################
declare -r TITLEBAR="AI BOOT" ESP_GUID="$(GET_PARTITION_ID efisp)"
declare OSCHROOT WIDEHACK="${GUI_WIDE}" ESPPARTS VALIDEFI
declare LDR_MTPT LDR_BDEV LDR_BPTH LDR_DISK LDR_PNUM LDR_PTYP LDR_UUID IMG_VLID
declare IMG_MTPT IMG_BDEV IMG_BPTH IMG_DISK IMG_PNUM IMG_PTYP IMG_UUID IMG_SBVL
declare FULLPATH MIRD_IMG RIRD_IMG
declare -a KRNTYPES KRN_IMGS MIR_IMGS RIR_IMGS
declare CPUMCODE MCODEIRD FULLPATH MIRD_IMG RIRD_IMG
declare RFS_TYPE RFS_BDEV RFS_SPEC RFS_UUID RFS_FLBL RFS_FLGS
declare OSR_NAME OSR_VRSN OSR_OSID

################################################################################
# Overly-cautious verification of required binaries
################################################################################

for CMD in cp dd df efibootmgr find head mkdir mv mount paste tail; do
    BIN["${CMD}"]="$(GET_COMMAND "${CMD}")" || ERR_LIST+="CRIT: Couldn't find ${CMD}\n"
done

CHECK_FOR_FAILURE_POINTS

function USE_PRIVILEGE {
  # This is just a wrapper so you don't have to type "${BIN[sudo]}" all the time
  GET_PRIVILEGE && "${BIN[sudo]}" "${@}" || return 1
}

function DEFAULT_MOUNT_OPTIONS {
  # The purpose here is to build a regex string for sed to use to exclude the
  # default mount options that show up in `mount`
  local -a DFLTOPTS

  # General default mount options
  DFLTOPTS+=('nodev')                 # do not interpret special devices on this filesystem
  DFLTOPTS+=('nosuid')                # do not honor set[ug]id bits on this filesystem
  DFLTOPTS+=('rw')                    # allow read/write access
  DFLTOPTS+=('relatime')              # access time updating
  DFLTOPTS+=('x-systemd[a-z.=-]\+')   # normally not interested in these for our purposes
  # BTRFS
  DFLTOPTS+=('space_cache')           # free space map caching
  DFLTOPTS+=('ssd')                   # this option is determined on mount
  DFLTOPTS+=('subvol=\/,')            # this is the default subvolume mounted
  DFLTOPTS+=('subvolid=[0-9]\+')      # ignore subvolids
  # F2FS
  DFLTOPTS+=('acl')                   # enable POSIX access control list
  DFLTOPTS+=('active_logs=6')         # number of active logs
  DFLTOPTS+=('alloc_mode=reuse')      # adjust block allocation policy to reuse
  DFLTOPTS+=('background_gc=on')      # garbage collection
  DFLTOPTS+=('discard')               # real-time TRIM
  DFLTOPTS+=('checkpoint_merge')      #
  DFLTOPTS+=('compress_log_size=2')   #
  DFLTOPTS+=('compress_mode=fs')      #
  DFLTOPTS+=('extent_cache')          # enable an extent cache based on rb-tree
  DFLTOPTS+=('flush_merge')           # merge concurrent cache flushes as much as possible
  DFLTOPTS+=('fsync_mode=posix')      # follow POSIX semantics for syncing to disk
  DFLTOPTS+=('inline_data')           # write small files into the inode block
  DFLTOPTS+=('inline_dentry')         # write small directories into the inode block
  DFLTOPTS+=('lazytime')              # only update times on the cache version
  DFLTOPTS+=('mode=adaptive')         # block allocation mode
  DFLTOPTS+=('no_heap')               # disable heap-style segment allocation
  DFLTOPTS+=('[nouseril]\+_xattr')    # disregard *_attr flags
  # FAT
  DFLTOPTS+=('codepage=437')          # default codepage
  DFLTOPTS+=('dmask=0022')            # pretend directory perms are 0755
  DFLTOPTS+=('errors=remount-ro')     # mount read-only on errors
  DFLTOPTS+=('fmask=0022')            # pretend file perms are 0755
  DFLTOPTS+=('iocharset=ascii')       # default character set
  DFLTOPTS+=('shortname=mixed')       # default shortname handling
  DFLTOPTS+=('utf8')                  # default filesystem-safe 8-bit encoding of unicode
  # NFS
  DFLTOPTS+=('addr=[0-9.:]\+')        # this is usually specified as the 'device'
  DFLTOPTS+=('local_lock=none')       # no file locking
  DFLTOPTS+=('namlen=[0-9]\+')        # this is negotiated
  DFLTOPTS+=('clientaddr=[0-9.:]\+')  # always the local machine
  DFLTOPTS+=('[rw]size=[0-9]\+')      # this is negotiated
  DFLTOPTS+=('proto=tcp')             # this is negotiated
  DFLTOPTS+=('timeo=600')             # default timeout
  DFLTOPTS+=('retrans=2')             # default retransmission attempts
  DFLTOPTS+=('sec=sys')               # default security handling
  # NTFS
  DFLTOPTS+=('allow_other')           # allow others read access
  DFLTOPTS+=('blksize=[0-9]\+')       # this is determined on mount
  DFLTOPTS+=('group_id=[0-9]\+')      # determined by who mounted
  DFLTOPTS+=('user_id=[0-9]\+')       # determined by who mounted
  # XFS
  DFLTOPTS+=('attr2')                 # enable improved inline extended attribute storage
  DFLTOPTS+=('inode64')               # enable 64-bit inode numbers
  DFLTOPTS+=('logbufs=8')             # number of in-memory log buffers
  DFLTOPTS+=('logbsize=32k')          # size of each in-memory log buffer
  DFLTOPTS+=('noquota')               # disable all quota accounting and enforcement

  REGEXSTR="\("
  for MTOPTION in "${DFLTOPTS[@]}"; do
    REGEXSTR+="${MTOPTION}\|"
  done
  REGEXSTR="${REGEXSTR%\\|}"
  REGEXSTR+="\),\?"
  echo "${REGEXSTR}"
}

function CHOOSE_EFI_STANDARD_OR_DEFAULT {
  ##############################################################################
  local -r BAKTITLE='Installation Type'
  local -r HELP_MSG='Do you want to install normally, or as a default bootloader?'
  ##############################################################################
  local -a SUGGESTS DESCRIPS
  local LOCATION="${1}"

  SUGGESTS=("${LOCATION}" "${LOCATION%%/EFI*}/EFI/Boot")
  DESCRIPS=("Install bootloader normally (in /EFI${LOCATION##*/EFI}) and create boot entry if needed"
            "Install bootloader as default (in /EFI/Boot) and do not create a boot entry")

  DIALOG_SINGLE_SELECT "${TITLEBAR}" "${BAKTITLE}" 'hidetags' "${LOCATION}" \
    "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' || return 1
}

function CHOOSE_REFIND_THEME {
  ##############################################################################
  local -r BAKTITLE="rEFInd Theme"
  local -r HELP_MSG="Which theme do you want to use?"
  ##############################################################################
  local -a RFTHEMES

  IFS=$'\n' read -r -d '' -a RFTHEMES < <("${BIN[find]}" "${LDR_MTPT}/EFI/refind" -mindepth 2 -type d -name 'icons' | "${BIN[sed]}" "s|${LDR_MTPT}/EFI/refind/\(.*\)/icons|\1|g")
  [[ ${#RFTHEMES[@]} -eq 0 ]] && echo 'default' > /tmp/selection && return 0
  RFTHEMES+=('default')

  DIALOG_SINGLE_SELECT "${TITLEBAR}" "${BAKTITLE}" "hidetags" '' \
    "${HELP_MSG}" 'RFTHEMES' 'RFTHEMES' || return 1
}

function CHOOSE_KCL_OPTIONS {
  ##############################################################################
  local -r BAKTITLE="Kernel Command Line Options"
  local -r HELP_MSG="Choose which options you want:"
  ##############################################################################
  local -a SUGGESTS DESCRIPS SELSTATE UHKCLOPS

  SUGGESTS=('acpi_backlight=vendor' 'consoleblank=0' 'ipv6.disable=1' 'net.ifnames=0' 'nvidia-drm.modeset=1' quiet)
  DESCRIPS=('Prefer vendor-specific acpi_backlight driver'
             "Don'\\''t blank the physical console"
             'Disable IPv6'
             'Disable persistent network interface names (go back to eth[n], etc.)'
             'Enable kernel mode setting for proprietary NVIDIA drives'
             'No init output except for errors')

  for KRNL_OPT in "${SUGGESTS[@]}"; do
    "${BIN[grep]}" -qs "${KRNL_OPT}" /proc/cmdline && SELSTATE+=('on') || SELSTATE+=('off')
  done

  IFS=$'\n' read -r -d '' -a UHKCLOPS < <(FIND_UNHANDLED_KCL_OPTIONS)

  for KRNL_OPT in "${UHKCLOPS[@]}"; do
    SUGGESTS+=("${KRNL_OPT}")
    DESCRIPS+=("[discovered unhandled kernel command line parameter in /proc/cmdline]")
    SELSTATE+=('on')
  done

  DIALOG_MULTI_SELECT "${TITLEBAR}" "${BAKTITLE}" 'showtags' \
    "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' 'SELSTATE' || return "${?}"
}

function FIND_UNHANDLED_KCL_OPTIONS {
  local -a HANDLED
  local GREP_STR

  # Handled as part of LUKS discovery
  HANDLED+=(cryptdevice= cryptkey= crypto=)
  # Options given by CHOOSE_KCL_OPTIONS
  HANDLED+=(acpi_backlight=vendor)
  HANDLED+=(consoleblank=0)
  HANDLED+=(ipv6.disable=1 net.ifnames=0)
  HANDLED+=(nvidia-drm.modeset=1)
  HANDLED+=(quiet)
  # Handled as part of Plymouth of discovery
  HANDLED+=(splash loglevel=3 rd.systemd.show_status=auto rd.udev.log_priority=3 vt.global_cursor_default=0)
  # Normally derived
  HANDLED+=(initrd= root= rootflags= zfs=)
  # Forbidden -- handled in relation to the init system
  HANDLED+=(ro rw)

  for KCL_OPTN in "${HANDLED[@]}"; do
    GREP_STR+="${KCL_OPTN}\|"
  done
  GREP_STR="${GREP_STR%\\|}"

  "${BIN[cat]}" /proc/cmdline | "${BIN[tr]}" ' ' '\n' | "${BIN[grep]}" -v "${GREP_STR}"
}

function GET_ACTIVE_STANZA_REFIND {
  local GREP_STR CFG_FILE
  GREP_STR="menuentry\s+\"?${1}\"?\s+{\n([[:print:]\t]+(?<!disabled)\n)+}\n"
  CFG_FILE="${LDR_MTPT}/EFI/refind/refind.conf"
  "${BIN[grep]}" -Pzo "${GREP_STR}" "${CFG_FILE}" | "${BIN[tr]}" -d '\0'
}

function GET_ACTIVE_STANZA_NAMES_REFIND {
  local GREP_STR CFG_FILE
  GREP_STR="menuentry\s+\"?[[:alnum:] ]+\"?\s+{\n([[:print:]\t]+(?<!disabled)\n)+}\n"
  CFG_FILE="${LDR_MTPT}/EFI/refind/refind.conf"
  "${BIN[grep]}" -Pzo "${GREP_STR}" "${CFG_FILE}" | "${BIN[tr]}" -d '\0' | \
  "${BIN[grep]}" -P 'menuentry(?<!submenuentry)' | \
  "${BIN[sed]}" 's/menuentry //g;s/[ \t]*{.*$//g' | "${BIN[tr]}" -d '"'
}

function GET_STANZA_LAYOUT_SYSLINUX {
  local CFG_LINE INT_LINE MENU_LVL
  [[ -e "${1}" ]] || return 0

  while read -r CFG_LINE; do
    if [[ ${CFG_LINE} =~ ^[[:blank:]]*MENU[[:blank:]]+BEGIN ]]; then
      INT_LINE="${CFG_LINE// /}"
      INT_LINE="${INT_LINE//$'\t'/}"
      MENU_LVL+="${INT_LINE#MENUBEGIN} » "
      echo "${MENU_LVL}[begin]"
    fi
    if [[ ${CFG_LINE} =~ ^[[:blank:]]*LABEL ]]; then
      INT_LINE="${CFG_LINE// /}"
      INT_LINE="${INT_LINE//$'\t'/}"
      echo "${MENU_LVL}${INT_LINE#LABEL}"
    fi
    if [[ ${CFG_LINE} =~ ^[[:blank:]]*MENU[[:blank:]]+END ]]; then
      echo "${MENU_LVL}[end]"
      if [[ $(echo "${MENU_LVL// /}" | "${BIN[tr]}" -dc '»' | "${BIN[wc]}" -c) -eq 2 ]]; then
        unset MENU_LVL
      else
        MENU_LVL="${MENU_LVL% » * » } » "
      fi
    fi
  done < "${1}"
}

function GET_STANZA_SYSLINUX {
  local SERCHFOR="${1}"
  SERCHFOR="${SERCHFOR% » \[*\]}"
  SERCHFOR="${SERCHFOR##* » }"
  local MENU_STR="(?s)[ \t]*MENU[ \t]+BEGIN[ \t]+${SERCHFOR}.*?MENU[ \t]+END[ \t]+${SERCHFOR}"
  local LABELSTR="(?s)[ \t]*LABEL[ \t]+${SERCHFOR}[ \t]*\n([ \t]*(MENU LABEL|LINUX|APPEND|INITRD)[^\n]+[\n])+"
  local MBEG_STR="(?s)[ \t]*MENU[ \t]+BEGIN[ \t]+${SERCHFOR}[ \t]*\n*MENU[ \t]+LABEL[^\n]+"
  local MEND_STR="(?s)[ \t]*MENU[ \t]+END[ \t]+${SERCHFOR}[ \t]*\n"

  if [[ ${1} =~ '[begin]' ]]; then
    "${BIN[grep]}" -Pzos "${MBEG_STR}" "${2}" | "${BIN[tr]}" -d '\0'
  elif [[ ${1} =~ '[end]' ]]; then
    "${BIN[grep]}" -Pzos "${MEND_STR}" "${2}" | "${BIN[tr]}" -d '\0'
  elif [[ $("${BIN[grep]}" "\s${SERCHFOR}\s*$" "${2}") =~ BEGIN ]]; then
    "${BIN[grep]}" -Pzos "${MENU_STR}" "${2}" | "${BIN[tr]}" -d '\0'
  else
    "${BIN[grep]}" -Pzos "${LABELSTR}" "${2}" | "${BIN[tr]}" -d '\0'
  fi
}

function GET_LUKS_KCL {
  DUMPINFO="$(USE_PRIVILEGE /sbin/cryptsetup luksDump "${1}")"
  LUKSUUID="$("${BIN[grep]}" 'UUID' <<< "${DUMPINFO}" | "${BIN[sed]}" 's/.*\s\+//g')"
  CPHRNAME="$("${BIN[grep]}" 'Cipher name' <<< "${DUMPINFO}" | "${BIN[sed]}" 's/.*\s\+//g')"
  CPHRMODE="$("${BIN[grep]}" 'Cipher mode' <<< "${DUMPINFO}" | "${BIN[sed]}" 's/.*\s\+//g')"
  HASHSPEC="$("${BIN[grep]}" Hash <<< "${DUMPINFO}" | "${BIN[sed]}" 's/.*\s\+//g')"
  KEY_SIZE="$("${BIN[grep]}" 'MK bits' <<< "${DUMPINFO}" | "${BIN[sed]}" 's/.*\s\+//g')"
  CRYPTDVC="cryptdevice=/dev/disk/by-uuid/${LUKSUUID}"
  CRYPTOCL="crypto=${HASHSPEC}:${CPHRNAME}-${CPHRMODE}:${KEY_SIZE}:0:"
  echo "${CRYPTOCL} ${CRYPTDVC}"
}

function GET_OPTINFO_REFIND {
  local CFG_OPTN="${1}"

  # This is a hack to distinguish 'banner' from 'banner_scale'
  # Since use_graphics_for can legitmately be unset, we can't rely on a
  # whitespace character always following an option name
  [[ ${CFG_OPTN} == banner ]] && CFG_OPTN='banner\s'

  "${BIN[grep]}" -Pzo "(?s)\n(#[^\n]*\n)*#?${CFG_OPTN}[^\n]*\n" "${LDR_MTPT}/EFI/refind/refind.conf" | \
    "${BIN[tr]}" -d '\0' | "${BIN[grep]}" '^# ' | \
    "${BIN[sed]}" "s/# //g;s/'/'\\\''/g" | \
    "${BIN[sed]}" ':a;N;$!ba;s/\n \{3,\}/ /g;s/what\norder/what order/g;s/all\nOSes/all OSes/g;s/the\nEFI/the EFI/g;s/\n\([a-z(]\+\)/ \1/g;s/\n\([A-Z(]\+\)/\n\n\1/g;' | \
    "${BIN[sed]}" 's/^ \+-\? \?\**/• /g' |
    "${BIN[sed]}" ':a;N;$!ba;s/\(\(\n•[^\n]\+\)\+\)/\n\1/g'
}

function GET_OPTINFO_SYSLINUX {
  case "${1}" in
    DEFAULT)
      "${BIN[cat]}" <<- ENDOFSCRIPT
			Set the default boot entry which will launch after TIMEOUT÷10 seconds.
			ENDOFSCRIPT
      ;;
    PROMPT)
      "${BIN[cat]}" <<- ENDOFSCRIPT
			Display the boot: prompt only if the Shift or Alt key is pressed, or Caps
			Lock or Scroll lock is set? (Otherwise always display the boot: prompt.)
			ENDOFSCRIPT
      ;;
    TIMEOUT)
      "${BIN[cat]}" <<- ENDOFSCRIPT
			If more than one label entry is available, this directive indicates how
			long to pause at the boot: prompt until booting automatically, in units
			of tenths of a second. The timeout is cancelled when any key is pressed,
			the assumption being the user will complete the command line. A timeout
			of zero will disable the timeout completely. The default is 0.
			
			When only one label entry is available, the timeout is ignored. To avoid
			automatically and immediately booting the (only and default) entry, use
			"PROMPT 1" too, or add at least one additional label entry.
			ENDOFSCRIPT
      ;;
    'MENU BACKGROUND')
      "${BIN[cat]}" <<- ENDOFSCRIPT
			Sets the background image for vesamenu
			ENDOFSCRIPT
      ;;
    'MENU TITLE')
      "${BIN[cat]}" <<- ENDOFSCRIPT
			Give the menu a title. The title is presented at the top of the menu.
			ENDOFSCRIPT
      ;;
    UI)
      "${BIN[cat]}" <<- ENDOFSCRIPT
			Use the graphical menu?  (Otherwise, use text only mode.)
			ENDOFSCRIPT
      ;;
  esac
}

function GET_OPTINFO_SYSTEMD_BOOT {
  case "${1}" in
    default)
      "${BIN[cat]}" <<- ENDOFSCRIPT
			Select the default entry. The default entry may be changed in the boot
			menu itself, in which case the name of the selected entry will be stored
			as an EFI variable, overriding this option.
			ENDOFSCRIPT
      ;;
    timeout)
      "${BIN[cat]}" <<- ENDOFSCRIPT
			How long the boot menu should be shown before the default entry is
			booted, in seconds. This may be changed in the boot menu itself and will
			be stored as an EFI variable in that case, overriding this option. If the
			timeout is disabled, the default entry will be booted immediately. The menu
			can be shown by pressing and holding a key before systemd-boot is launched.
			ENDOFSCRIPT
      ;;
    console-mode)
      "${BIN[cat]}" <<- ENDOFSCRIPT
			Configure the resolution of the console.
			ENDOFSCRIPT
      ;;
    editor)
      "${BIN[cat]}" <<- ENDOFSCRIPT
			Enable the kernel command line editor? The editor should be
			disabled if the machine can be accessed by unauthorized persons.
			ENDOFSCRIPT
      ;;
    auto-entries)
      "${BIN[cat]}" <<- ENDOFSCRIPT
			Enable the disable entries for other boot entries found on the boot
			partition? In particular, this may be useful when loader entries are
			created to show replacement descriptions for those entries.
			ENDOFSCRIPT
      ;;
    auto-firmware)
      echo 'Enable the "Reboot into firmware" entry?'
      ;;
    random-seed-mode)
      echo 'How should systemd-boot handle the random-seed file?'
      ;;
  esac

}

function CONFIGURE_REFIND {
  local CFG_FILE="${LDR_MTPT}/EFI/refind/refind.conf"
  local CFG_OPTN EXISTCFG HELP_MSG BOOLTRUE BOOLNOPE
  local -a SUGGESTS DESCRIPS SELSTATE
  local -ra LOOK_FOR=(timeout:range use_nvram:bool banner:select textonly:bool
                      textmode:select resolution:text use_graphics_for:multi
                      showtools:text scanfor:text dont_scan_dirs:text
                      scan_all_linux_kernels:bool default_selection:select)

  for CFG_OPTN in "${LOOK_FOR[@]}"; do
    [[ ${CFG_OPTN%:*} == showtools ]] && GUI_WIDE=768
    [[ ${CFG_OPTN%:*} == default_selection ]] && GUI_WIDE=768
    [[ ${CFG_OPTN%:*} == scanfor ]] && GUI_WIDE="${WIDEHACK}"
    EXISTCFG="$("${BIN[grep]}" "^\s*#*${CFG_OPTN%:*}" "${CFG_FILE}" | ${BIN[cut]} -d\  -f2- | "${BIN[tail]}" -1)"
    HELP_MSG="$(GET_OPTINFO_REFIND "${CFG_OPTN%:*}")"
    unset SUGGESTS DESCRIPS SELSTATE
    case "${CFG_OPTN#*:}" in
      bool)
        [[ ${CFG_OPTN#*:} == textonly ]] && BOOLTRUE=1 && BOOLNOPE=0
        [[ ${CFG_OPTN#*:} != textonly ]] && BOOLTRUE='true' && BOOLNOPE='false'
        DIALOG_YESNO "${TITLEBAR}" "${CFG_OPTN%:*}" "${HELP_MSG}" \
          && echo "${BOOLTRUE}" > /tmp/selection || echo "${BOOLNOPE}" > /tmp/selection
        ;;
      text)
        DIALOG_INPUT "${TITLEBAR}" "${CFG_OPTN%:*}" "${HELP_MSG}" "${EXISTCFG}" || return 1
        ;;
      multi)
        case "${CFG_OPTN%:*}" in
          use_graphics_for)
            SUGGESTS+=(elilo grub linux osx windows)
            DESCRIPS+=('The ELILO boot loader' 'The GRUB (Legacy or 2) boot loader'
                       'A Linux kernel with EFI stub loader' macOS 'Microsoft Windows')
            for OPTION in "${SUGGESTS[@]}"; do
              "${BIN[grep]}" -qs "^use_graphics_for.*${OPTION}" "${CFG_FILE}" \
                && SELSTATE+=(on) || SELSTATE+=(off)
            done
            ;;
        esac
        DIALOG_MULTI_SELECT "${TITLEBAR}" "${CFG_OPTN%:*}" 'showtags' \
          "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' 'SELSTATE' || return 1
        ;;
      select)
        case "${CFG_OPTN%:*}" in
          banner)
            IFS=$'\n' read -r -d '' -a SUGGESTS < <("${BIN[find]}" "${CFG_FILE%\/refind.conf}" \( -name '*.bmp' -o -name '*.jpg' -o -name '*.png' \) | ${BIN[grep]} -v '/icons/\|/fonts/\|/selection[a-z_]\+\.png' | ${BIN[sed]} "s|${CFG_FILE%\/refind.conf}/||g")
            IFS=$'\n' read -r -d '' -a DESCRIPS < <("${BIN[find]}" "${CFG_FILE%\/refind.conf}" \( -name '*.bmp' -o -name '*.jpg' -o -name '*.png' \) | ${BIN[grep]} -v '/icons/\|/fonts/\|/selection[a-z_]\+\.png' | ${BIN[sed]} "s|${CFG_FILE%\/refind.conf}/||g")
            ;;
          textmode)
            SUGGESTS=(0 1 2 1024)
            DESCRIPS=('Standard UEFI 80x25 mode'
                      '80x50 mode, not supported by all devices'
                      'First non-standard mode provided by the firmware, if any'
                      'Keep the mode selected by firmware (the default)')
            ;;
          default_selection)
            LC=0
            while read -r BT_ENTRY; do
              ((LC++))
              SUGGESTS+=("${LC}")
              DESCRIPS+=("${BT_ENTRY}")
            done < <(GET_ACTIVE_STANZA_NAMES_REFIND)
            ;;
        esac
        [[ ${CFG_OPTN%:*} == banner ]] && TAG_VIEW='hidetags' || TAG_VIEW='showtags'
        [[ ${#SUGGESTS[@]} -eq 0 ]] && continue
        DIALOG_SINGLE_SELECT "${TITLEBAR}" "${CFG_OPTN%:*}" "${TAG_VIEW}" "${EXISTCFG}" \
          "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' || return 1
        ;;
      range)
        DIALOG_RANGE "${TITLEBAR}" "${CFG_OPTN%:*}" "${HELP_MSG}" 0 60 2 || return 1
        ;;
    esac
    SELECTED="$(</tmp/selection)"
    USE_PRIVILEGE "${BIN[sed]}" -i "s|^\s*#*${CFG_OPTN%:*}\s\+.*|${CFG_OPTN%:*} ${SELECTED}|g" "${CFG_FILE}"
    # Some places in the config file have commented-out examples.
    # This script ends up changing them all the what the user set.
    # While this doesn't affect anything functionality-wise, it
    # doesn't look professional so let's clean it up.
    USE_PRIVILEGE "${BIN[sed]}" -i ':a;N;$!ba;'"s|\(${CFG_OPTN%:*} ${SELECTED}\n\)\{2,\}|${CFG_OPTN%:*} ${SELECTED}\n|g" "${CFG_FILE}"
  done
}

function CONFIGURE_SYSLINUX {
  local CFG_OPTN EXISTCFG CFG_FILE SUGGESTS DESCRIPS SELSTATE
  local -ra LOOK_FOR=(TIMEOUT:range PROMPT:bool UI:bool DEFAULT:select
                      'MENU BACKGROUND:select' 'MENU TITLE:text')

  if [[ ${VALIDEFI+y} == y ]]; then
    CFG_FILE="${LDR_MTPT}/EFI/syslinux/syslinux.cfg"
  else
    CFG_FILE="${IMG_PATH}/syslinux/syslinux.cfg"
  fi

  for CFG_OPTN in "${LOOK_FOR[@]}"; do
    EXISTCFG="$("${BIN[grep]}" -s "^\s*#*${CFG_OPTN%:*}" "${CFG_FILE}" | "${BIN[sed]}" "s/^\s*#*${CFG_OPTN%:*}\s*//g"  | "${BIN[tail]}" -1)"
    HELP_MSG="$(GET_OPTINFO_SYSLINUX "${CFG_OPTN%:*}")"
    unset SUGGESTS DESCRIPS SELSTATE
    case "${CFG_OPTN#*:}" in
      bool)
        [[ ${CFG_OPTN%:*} == PROMPT ]] && BOOLTRUE=0 && BOOLNOPE=1
        [[ ${CFG_OPTN%:*} == UI ]] && BOOLTRUE='vesamenu' && BOOLNOPE='menu'
        DIALOG_YESNO "${TITLEBAR}" "${CFG_OPTN%:*}" "${HELP_MSG}" \
          && echo "${BOOLTRUE}" > /tmp/selection || echo "${BOOLNOPE}" > /tmp/selection
        ;;
      text)
        DIALOG_INPUT "${TITLEBAR}" "${CFG_OPTN%:*}" "${HELP_MSG}" "${EXISTCFG}" || return 1
        ;;
      select)
        case "${CFG_OPTN%:*}" in
          DEFAULT)
            while read -r BT_ENTRY; do
              SUGGESTS+=("${BT_ENTRY##* » }")
              DESCRIPS+=("${BT_ENTRY}")
            done < <(GET_STANZA_LAYOUT_SYSLINUX "${CFG_FILE}" | "${BIN[grep]}" -v '\[')
            ;;
          'MENU BACKGROUND')
            IFS=$'\n' read -r -d '' -a SUGGESTS < <("${BIN[find]}" "${CFG_FILE%\/syslinux.conf}" \( -name '*.bmp' -o -name '*.jpg' -o -name '*.png' \) | ${BIN[grep]} -v '/icons/\|/fonts/\|/selection[a-z_]\+\.png' | ${BIN[sed]} "s|${CFG_FILE%\/syslinux.conf}/||g")
            IFS=$'\n' read -r -d '' -a DESCRIPS < <("${BIN[find]}" "${CFG_FILE%\/syslinux.conf}" \( -name '*.bmp' -o -name '*.jpg' -o -name '*.png' \) | ${BIN[grep]} -v '/icons/\|/fonts/\|/selection[a-z_]\+\.png' | ${BIN[sed]} "s|${CFG_FILE%\/syslinux.conf}/||g")
            ;;
        esac
        [[ ${CFG_OPTN%:*} == 'MENU BACKGROUND' ]] && TAG_VIEW='hidetags' || TAG_VIEW='showtags'
        [[ ${#SUGGESTS[@]} -eq 0 ]] && continue
        DIALOG_SINGLE_SELECT "${TITLEBAR}" "${CFG_OPTN%:*}" "${TAG_VIEW}" "${EXISTCFG}" \
          "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' || return 1
        ;;
      range)
        DIALOG_RANGE "${TITLEBAR}" "${CFG_OPTN%:*}" "${HELP_MSG}" 0 60 2 || return 1
        ;;
    esac
    SELECTED="$(</tmp/selection)"
    if "${BIN[grep]}" -qs "^\s*${CFG_OPTN%:*}" "${CFG_FILE}"; then
      USE_PRIVILEGE "${BIN[sed]}" -i "s|^\s*#*${CFG_OPTN%:*}\s\+.*|${CFG_OPTN%:*} ${SELECTED}|g" "${CFG_FILE}"
      # Some places in the config file have commented-out examples.
      # This script ends up changing them all the what the user set.
      # While this doesn't affect anything functionality-wise, it
      # doesn't look professional so let's clean it up.
      USE_PRIVILEGE "${BIN[sed]}" -i ':a;N;$!ba;'"s|\(${CFG_OPTN%:*} ${SELECTED}\n\)\{2,\}|${CFG_OPTN%:*} ${SELECTED}\n|g" "${CFG_FILE}"
    else
      USE_PRIVILEGE "${BIN[sed]}" -i "1i${CFG_OPTN%:*} ${SELECTED}" "${CFG_FILE}"
    fi
  done
}

function CONFIGURE_SYSTEMD_BOOT {
  local CFG_OPTN EXISTCFG CFG_FILE="${LDR_MTPT}/loader/loader.conf"
  local HELP_MSG XTRATABS
  local -ra LOOK_FOR=(default:select timeout:range console-mode:select editor:bool
                      auto-entries:bool auto-firmware:bool random-seed-mode:select)

  for CFG_OPTN in "${LOOK_FOR[@]}"; do
    EXISTCFG="$("${BIN[grep]}" -s "^${CFG_OPTN%:*}" "${CFG_FILE}" | ${BIN[sed]} 's/.*\s//g')"
    HELP_MSG="$(GET_OPTINFO_SYSTEMD_BOOT "${CFG_OPTN%:*}")"
    case "${CFG_OPTN#*:}" in
      bool)
        DIALOG_YESNO "${TITLEBAR}" "${CFG_OPTN%:*}" "${HELP_MSG}" \
          && echo 'yes' > /tmp/selection || echo 'no' > /tmp/selection
        ;;
      text)
        DIALOG_INPUT "${TITLEBAR}" "${CFG_OPTN%:*}" "${HELP_MSG}" "${EXISTCFG}" || return 1
        ;;
      select)
        case "${CFG_OPTN%:*}" in
          default)
            IFS=$'\n' read -r -d '' -a SUGGESTS < <("${BIN[find]}" "${LDR_MTPT}"/loader/entries -name '*.conf' | "${BIN[sed]}" 's|.*/||g' | "${BIN[sort]}")
            IFS=$'\n' read -r -d '' -a DESCRIPS < <("${BIN[grep]}" '^title' "${LDR_MTPT}"/loader/entries/*.conf | ${BIN[sort]} | "${BIN[sed]}" 's/.*title\s\+//g')
            ;;
          console-mode)
            SUGGESTS=(0 1 2 auto max keep)
            DESCRIPS=('Standard UEFI 80x25 mode'
                      '80x50 mode, not supported by all devices'
                      'First non-standard mode provided by the firmware, if any'
                      'Pick a suitable mode automatically using heuristics'
                      'Pick the highest-numbered available mode'
                      'Keep the mode selected by firmware (the default)')
            ;;
          random-seed-mode)
            SUGGESTS=(off with-system-token always)
            DESCRIPS=('Never read ESP random seed, nor pass it to the OS'
                      'Only read ESP random seed if LoaderSystemToken EFI var is set (default)'
                      'Read random seed regardless if LoaderSystemToken EFI var is set')
            ;;
        esac
        DIALOG_SINGLE_SELECT "${TITLEBAR}" "${CFG_OPTN%:*}" 'showtags' "${EXISTCFG}" \
          "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' || return 1
        ;;
      range)
        DIALOG_RANGE "${TITLEBAR}" "${CFG_OPTN%:*}" "${HELP_MSG}" 0 60 2 || return 1
        ;;
    esac
    SELECTED="$(</tmp/selection)"
    USE_PRIVILEGE "${BIN[sed]}" -i "/${CFG_OPTN%:*}/d" "${CFG_FILE}"
    unset XTRATABS
    [[ $(echo "${CFG_OPTN%:*}" | "${BIN[wc]}" -m) -lt 17 ]] && XTRATABS="\t"
    [[ $(echo "${CFG_OPTN%:*}" | "${BIN[wc]}" -m) -lt 9 ]] && XTRATABS="\t\t"
    USE_PRIVILEGE sh -c "'${BIN[printf]}' '%b\t%s\n' '${CFG_OPTN%:*}${XTRATABS}' '${SELECTED}' >> '${CFG_FILE}'"
  done
}

function GENERATE_BOOT_STANZA {
  local LUKS_DVC LUKSKCLP PLYMKCLP ADDLKCLP

  if [[ ${RFS_BDEV} =~ /dev/mapper ]]; then
    GET_PRIVILEGE
    LUKS_DVC="$(USE_PRIVILEGE /sbin/cryptsetup status "${RFS_BDEV##*/}" | "${BIN[grep]}" 'device:' | "${BIN[sed]}" 's/.* //g')"
    LUKSKCLP="$(GET_LUKS_KCL "${LUKS_DVC}"):${RFS_BDEV##*/}"
    if [[ $(</proc/cmdline) =~ cryptkey ]]; then
      if DIALOG_YESNO "${TITLEBAR}" "CryptKey" "Use cryptkey from kernel command line?"; then
        LUKSKCLP+=" cryptkey=$("${BIN[sed]}" 's/.*cryptkey=\(.*\) \?/\1/g' /proc/cmdline)"
      fi
    fi
  fi

  [[ -e ${OSCHROOT}/usr/share/plymouth ]] && \
    PLYMKCLP="splash loglevel=3 rd.udev.log_priority=3 rd.systemd.show_status=auto vt.global_cursor_default=0"

  CHOOSE_KCL_OPTIONS || return 1
  ADDLKCLP="rw $(</tmp/selection)"
  ADDLKCLP="${ADDLKCLP//  / }"

  case "${1}" in
    refind)
      GENERATE_BOOT_STANZA_REFIND       "${ADDLKCLP}" "${PLYMKCLP}" "${LUKSKCLP}";;
    syslinux)
      GENERATE_BOOT_STANZA_SYSLINUX     "${ADDLKCLP}" "${PLYMKCLP}" "${LUKSKCLP}";;
    systemd-boot)
      GENERATE_BOOT_STANZA_SYSTEMD_BOOT "${ADDLKCLP}" "${PLYMKCLP}" "${LUKSKCLP}";;
  esac
}

function GENERATE_BOOT_STANZA_REFIND {
  [[ -n "${1}" ]] && local ADDLKCLP="${1}" || unset ADDLKCLP
  [[ -n "${2}" ]] && local PLYMKCLP="${2}" || unset PLYMKCLP
  [[ -n "${3}" ]] && local LUKSKCLP="${3}" || unset LUKSKCLP
  local CFG_FILE USETHEME BAKTITLE HELP_MSG DFLTSLCT SELECTED BTSTANZA EXSTANZA STNZATTL
  local -a ASTANZAS SUGGESTS DESCRIPS
  local -i LC

  CFG_FILE="${LDR_MTPT}/EFI/refind/refind.conf"
  CHOOSE_REFIND_THEME
  USETHEME="/EFI/refind/$(</tmp/selection)/icons"
  USETHEME="${USETHEME%/default}"
  [[ -n ${MCODEIRD} ]] && MCODEIRD="initrd=${MCODEIRD}"
  [[ -n ${MCODEIRD} ]] && MCODEIRD="${MCODEIRD/ / initrd=}"

  for (( LC=0 ; LC<${#KRN_IMGS[@]} ; LC++ )); do
    BTSTANZA="menuentry \"${OSR_NAME}${OSR_VRSN+ }${OSR_VRSN}${KRNTYPES[${LC}]+ }${KRNTYPES[${LC}]^}\" {\n"
    BTSTANZA+="\ticon\t${USETHEME}/os_${OSR_OSID}.png\n"
    BTSTANZA+="\tvolume\t${IMG_PLBL:-${IMG_UUID}}\n"
    BTSTANZA+="\tloader\t${KRN_IMGS[${LC}]}\n"
    [[ -n ${MIR_IMGS[${LC}]} ]] && BTSTANZA+="\tinitrd\t${MIR_IMGS[${LC}]}\n"
    BTSTANZA+="\toptions\t\"${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP}${LUKSKCLP+ }${LUKSKCLP}${PLYMKCLP+ }${PLYMKCLP}${MCODEIRD+ }${MCODEIRD//\//\\\\}\"\n"
    if [[ ${ADDLKCLP} =~ quiet ]]; then
      STNZATTL='Verbose startup'
      [[ -z ${PLMTHKCL} ]] && STNZATTL="${STNZATTL#V/No splash & v}"
      BTSTANZA+="\tsubmenuentry \"${STNZATTL}\" {\n"
      BTSTANZA+="\t\toptions\t\"${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / /}${LUKSKCLP+ }${LUKSKCLP}${MCODEIRD+ }${MCODEIRD//\//\\\\}\"\n"
      BTSTANZA+="\t}\n"
    fi
    if [[ -e ${OSCHROOT}/etc/systemd/system/display-manager.service ]]; then
      BTSTANZA+='\tsubmenuentry "Boot to CLI (no display manager) {\n'
      BTSTANZA+="\t\toptions\t\"${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / /}${LUKSKCLP+ }${LUKSKCLP} systemd.unit=multi-user.target${MCODEIRD+ }${MCODEIRD//\//\\\\}\"\n"
      BTSTANZA+='\t}\n'
    fi
    if [[ ${MIR_IMGS[${LC}]} != "${RIR_IMGS[${LC}]}" ]] && [[ -n ${RIR_IMGS[${LC}]} ]]; then
      BTSTANZA+='\tsubmenuentry "Boot with fallback InitRAMFS" {\n'
      BTSTANZA+="\t\tinitrd\t${RIR_IMGS[${LC}]}\n"
      BTSTANZA+="\t\toptions\t\"${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / /}${LUKSKCLP+ }${LUKSKCLP}${MCODEIRD+ }${MCODEIRD//\//\\\\}\"\n"
      BTSTANZA+='\t}\n'
    fi
    BTSTANZA+='\tsubmenuentry "Boot to systemd rescue.target" {\n'
    [[ -n ${RIR_IMGS[${LC}]} ]] && BTSTANZA+="\t\tinitrd ${RIR_IMGS[${LC}]}\n"
    BTSTANZA+="\t\toptions\t\"${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / /}${LUKSKCLP+ }${LUKSKCLP} systemd.unit=rescue.target${MCODEIRD+ }${MCODEIRD//\//\\\\}\"\n"
    BTSTANZA+='\t}\n'
    BTSTANZA+='}'
  done

  IFS=$'\n' read -r -d '' -a ASTANZAS < <(GET_ACTIVE_STANZA_NAMES_REFIND)
  DESCRIPS+=("${ASTANZAS[@]}" '[create new entry]')
  for (( LC=0 ; LC<${#DESCRIPS[@]} ; LC++ )); do
    SUGGESTS+=("${LC}")
    if [[ ${DESCRIPS[${LC}]} == ${OSR_NAME}${OSR_VRSN+ }${OSR_VRSN}${KRNTYPES[${LC}]+ }${KRNTYPES[${LC}]^} ]]; then
      DFLTSLCT="${LC}"
    fi
  done
  [[ -z ${DFLTSLCT} ]] && DFLTSLCT="${LC}"

  if [[ ${#SUGGESTS[@]} -gt 1 ]]; then
    ##############################################################################
    BAKTITLE="rEFInd Boot Entry Placement"
    HELP_MSG="Select the entry to replace:"
    ##############################################################################
    DIALOG_SINGLE_SELECT "${TITLEBAR}" "${BAKTITLE}" 'hidetags' "${DFLTSLCT}" \
      "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' || return 1
    SELECTED="$(</tmp/selection)"
    if [[ ${SELECTED} -eq ${SUGGESTS[-1]} ]]; then
      unset SUGGESTS DESCRIPS
      for (( LC=0 ; LC<${#ASTANZAS[@]} ; LC++ )); do
        if [[ ${LC} -eq 0 ]]; then
          DESCRIPS[${LC}]="Place first, before ${ASTANZAS[${LC}]}"
        else
          DESCRIPS[${LC}]="Place between ${ASTANZAS[$((LC-1))]} and ${ASTANZAS[${LC}]}"
        fi
        SUGGESTS+=("${LC}")
      done
      DESCRIPS[${LC}]="Place last, after ${ASTANZAS[$((LC-1))]}"
      SUGGESTS+=("${LC}")

      ############################################################################
      BAKTITLE="rEFInd Boot Entry Placement"
      HELP_MSG="Select where to insert the new entry:"
      ############################################################################
      DIALOG_SINGLE_SELECT "${TITLEBAR}" "${BAKTITLE}" 'hidetags' '' \
        "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' || return 1
      SELECTED="$(</tmp/selection)"

      if [[ ${SELECTED} -lt ${SUGGESTS[-1]} ]]; then
        EXSTANZA="$(GET_ACTIVE_STANZA_REFIND "${ASTANZAS[${SELECTED}]}")"
        EXSTANZA="${EXSTANZA//\\/\\\\}"
        EXSTANZA="${EXSTANZA//$'\n'/\\n}"
        EXSTANZA="${EXSTANZA//$'\t'/\\t}"
        USE_PRIVILEGE "${BIN[sed]}" -i ':a;N;$!ba;'"s|${EXSTANZA}|${BTSTANZA}\n\n${EXSTANZA}|g" "${CFG_FILE}"
      else
        EXSTANZA="$(GET_ACTIVE_STANZA_REFIND "${ASTANZAS[$((SELECTED-1))]}")"
        EXSTANZA="${EXSTANZA//\\/\\\\}"
        EXSTANZA="${EXSTANZA//$'\n'/\\n}"
        EXSTANZA="${EXSTANZA//$'\t'/\\t}"
        USE_PRIVILEGE "${BIN[sed]}" -i ':a;N;$!ba;'"s|${EXSTANZA}|${EXSTANZA}\n\n${BTSTANZA}|g" "${CFG_FILE}"
      fi

    else
      EXSTANZA="$(GET_ACTIVE_STANZA_REFIND "${DESCRIPS[${SELECTED}]}")"
      EXSTANZA="${EXSTANZA//\\/\\\\}"
      EXSTANZA="${EXSTANZA//$'\n'/\\n}"
      EXSTANZA="${EXSTANZA//$'\t'/\\t}"
      USE_PRIVILEGE "${BIN[sed]}" -i ':a;N;$!ba;'"s|${EXSTANZA}|${BTSTANZA}|g" "${CFG_FILE}"
    fi
  else
    USE_PRIVILEGE sh -c "'${BIN[printf]}' '|%b||' '${BTSTANZA}' | tr '|' '\n' >> '${CFG_FILE}'"
  fi
}

function MANAGE_SYSLINUX_TOOLS {
  local CFG_OPTN EXISTCFG CFG_FILE SUGGESTS DESCRIPS SELSTATE TYPE
  local -ra LOOK_FOR=(memtest86.bin hdt.c32 reboot.c32 poweroff.c32)
  local -ra DESCRIPS=(MemTest86+ 'Hardware Detectection Tool' Reboot 'Power Off')

  if [[ ${VALIDEFI+y} == y ]]; then
    CFG_FILE="${LDR_MTPT}/EFI/syslinux/syslinux.cfg"
  else
    CFG_FILE="${IMG_PATH}/syslinux/syslinux.cfg"
  fi

  for (( LC=0 ; LC<${#LOOK_FOR[@]} ; LC++ )); do
    # Set the SysLinux command that loads what we're looking for
    [[ ${LOOK_FOR[${LC}]} =~ bin ]] && TYPE='LINUX' || TYPE='COM32'
    # If using EFI, delete all of these entries.  For BIOS, ensure all are present
    [[ ${VALIDEFI+y} == y ]] && MODE='delete' || MODE='insert'
    # Except for Power Off, because it only works with APM which has been long deprecated
    [[ ${LOOK_FOR[${LC}]} =~ power ]] && MODE='delete'
    # If the memtest bin isn't present, then remove that as well.
    [[ ${LOOK_FOR[${LC}]} =~ memtest ]] && \
      [[ ! -e ${IMG_PATH}/memtest86+/memtest.bin ]] && MODE='delete'
    # Grab the stanza we're looking for, if present
    EXSTANZA="$("${BIN[grep]}" -Pzo "(?s)[ \t]*LABEL[ \t]+${LOOK_FOR[${LC}]%.*}.*?${LOOK_FOR[${LC}]}[ \t]*\n" "${CFG_FILE}" | "${BIN[tr]}" -d '\0' | "${BIN[sed]}" ':a;N;$!ba;'"s/\n/\\\n/g;")"
    # If the stanza to be inserted already exists, skip
    [[ ${MODE} == insert ]] && [[ -n ${EXSTANZA} ]] && continue
    [[ ${MODE} == delete ]] && [[ -z ${EXSTANZA} ]] && continue
    [[ ${MODE} == delete ]] && USE_PRIVILEGE sed -i ':a;N;$!ba;'"s|${EXSTANZA}||g" "${CFG_FILE}"
    [[ ${MODE} == insert ]] && \
      USE_PRIVILEGE sed -i "s|\(\s*LABEL\s\+${LOOK_FOR[$((LC+1))]%.*}\s*\)|LABEL ${LOOK_FOR[${LC}]%.*}\nMENU LABEL ${DESCRIPS[${LC}]}\n${TYPE} ${IMG_BPTH}/${LOOK_FOR[${LC}]/memtest.bin/metest86+\/memtest.bin}\n\n\1|g" "${CFG_FILE}"
  done
  return 0
}

function GENERATE_BOOT_STANZA_SYSLINUX {
  [[ -n "${1}" ]] && local ADDLKCLP="${1}" || unset ADDLKCLP
  [[ -n "${2}" ]] && local PLYMKCLP="${2}" || unset PLYMKCLP
  [[ -n "${3}" ]] && local LUKSKCLP="${3}" || unset LUKSKCLP
  local CFG_FILE USETHEME BAKTITLE HELP_MSG DFLTSLCT SELECTED BTSTANZA EXSTANZA STNZATTL
  local -a ASTANZAS SUGGESTS DESCRIPS
  local -i LC

  if [[ ${VALIDEFI+y} == y ]]; then
    CFG_FILE="${LDR_MTPT}/EFI/syslinux/syslinux.cfg"
  else
    CFG_FILE="${LDR_MTPT}${LDR_BPTH}/syslinux/syslinux.cfg"
  fi

  for (( LC=0 ; LC<${#KRN_IMGS[@]} ; LC++ )); do
    if [[ -n ${MCODEIRD}${MIR_IMGS[${LC}]} ]]; then
      [[ -n ${MCODEIRD} ]] && MAININIT="${MCODEIRD}"
      [[ -n ${MIR_IMGS[${LC}]} ]] && MAININIT="${MCODEIRD}${MCODEIRD+,}${MIR_IMGS[${LC}]}"
    fi
    if [[ -n ${MCODEIRD}${RIR_IMGS[${LC}]} ]]; then
      [[ -n ${MCODEIRD} ]] && RESCINIT="${MCODEIRD}"
      [[ -n ${MIR_IMGS[${LC}]} ]] && RESCINIT="${MCODEIRD}${MCODEIRD+,}${RIR_IMGS[${LC}]}"
    fi

    BTSTANZA="MENU BEGIN ${OSR_OSID}\n"
    BTSTANZA+="MENU LABEL ${OSR_NAME}${OSR_VRSN+ }${OSR_VRSN}${KRNTYPES[${LC}]+ }${KRNTYPES[${LC}]^}\n\n"

    BTSTANZA+="\tLABEL\t${OSR_OSID}-normal\n"
    BTSTANZA+="\tMENU LABEL Normal startup\n"
    BTSTANZA+="\tLINUX\t${KRN_IMGS[${LC}]}\n"
    BTSTANZA+="\tAPPEND\t${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP}${LUKSKCLP+ }${LUKSKCLP}${PLYMKCLP+ }${PLYMKCLP}\n"
    [[ -n ${MAININIT} ]] && BTSTANZA+="\tINITRD\t${MAININIT}\n\n"

    if [[ ${ADDLKCLP} =~ quiet ]]; then
      BTSTANZA+="\tLABEL\t${OSR_OSID}-verbose\n"
      STNZATTL="Verbose startup"
      [[ -z ${PLMTHKCL} ]] && STNZATTL="${STNZATTL#V/No splash & v}"
      BTSTANZA+="\tMENU LABEL ${STNZATTL}\n"
      BTSTANZA+="\tLINUX\t${KRN_IMGS[${LC}]}\n"
      BTSTANZA+="\tAPPEND\t${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / /}${LUKSKCLP+ }${LUKSKCLP}\n"
      [[ -n ${MAININIT} ]] && BTSTANZA+="\tINITRD\t${MAININIT}\n\n"
    fi

    if [[ -e ${OSCHROOT}/etc/systemd/system/display-manager.service ]]; then
      BTSTANZA+="\tLABEL\t${OSR_OSID}-cli\n"
      BTSTANZA+="\tMENU LABEL Boot to console\n"
      BTSTANZA+="\tLINUX\t${KRN_IMGS[${LC}]}\n"
      BTSTANZA+="\t\APPEND\t${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / /}${LUKSKCLP+ }${LUKSKCLP} systemd.unit=multi-user.target\n"
      [[ -n ${MAININIT} ]] && BTSTANZA+="\tINITRD\t${MAININIT}\n\n"
    fi

    if [[ ${MIR_IMGS[${LC}]} != "${RIR_IMGS[${LC}]}" ]] && [[ -n ${RIR_IMGS[${LC}]} ]]; then
      BTSTANZA+="\tLABEL\t${OSR_OSID}-fallback\n"
      BTSTANZA+="\tMENU LABEL Startup with fallback initramfs\n"
      BTSTANZA+="\tLINUX\t${KRN_IMGS[${LC}]}\n"
      BTSTANZA+="\tAPPEND\t${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / /}${LUKSKCLP+ }${LUKSKCLP}\n"
      [[ -n ${RESCINIT} ]] && BTSTANZA+="\tINITRD\t${RESCINIT}\n\n"
    fi

    BTSTANZA+="\tLABEL\t${OSR_OSID}-rescue\n"
    BTSTANZA+="\tMENU LABEL Boot to systemd rescue.target\n"
    BTSTANZA+="\tLINUX\t${KRN_IMGS[${LC}]}\n"
    BTSTANZA+="\tAPPEND\t${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / /}${LUKSKCLP+ }${LUKSKCLP} systemd.unit=rescue.target\n"
    [[ -n ${RESCINIT} ]] && BTSTANZA+="\tINITRD\t${RESCINIT}\n\n"

    BTSTANZA+="MENU END ${OSR_OSID}"
  done

  IFS=$'\n' read -r -d '' -a ASTANZAS < <(GET_STANZA_LAYOUT_SYSLINUX "${CFG_FILE}" | ${BIN[grep]} -v end | "${BIN[sed]}" 's/begin/entire menu/g')
  DESCRIPS+=("${ASTANZAS[@]}" '[create new entry]')
  for (( LC=0 ; LC<${#DESCRIPS[@]} ; LC++ )); do
    SUGGESTS+=("${LC}")
  done

  if [[ ${#SUGGESTS[@]} -gt 1 ]]; then
    ##############################################################################
    BAKTITLE="SysLinux Boot Entry Placement"
    HELP_MSG="Select the entry to replace:"
    ##############################################################################
    DIALOG_SINGLE_SELECT "${TITLEBAR}" "${BAKTITLE}" 'hidetags' "${DFLTSLCT}" \
      "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' || return 1
    SELECTED="$(</tmp/selection)"
    if [[ ${SELECTED} -eq ${SUGGESTS[-1]} ]]; then
      unset SUGGESTS DESCRIPS
      IFS=$'\n' read -r -d '' -a ASTANZAS < <(GET_STANZA_LAYOUT_SYSLINUX "${CFG_FILE}")
      for (( LC=0 ; LC<${#ASTANZAS[@]} ; LC++ )); do
        if [[ ${LC} -eq 0 ]]; then
          DESCRIPS[${LC}]="Place first, before ${ASTANZAS[${LC}]}"
        else
          DESCRIPS[${LC}]="Place between ${ASTANZAS[$((LC-1))]} and ${ASTANZAS[${LC}]}"
        fi
        SUGGESTS+=("${LC}")
      done
      DESCRIPS[${LC}]="Place last, after ${ASTANZAS[$((LC-1))]}"
      SUGGESTS+=("${LC}")

      ############################################################################
      BAKTITLE="rEFInd Boot Entry Placement"
      HELP_MSG="Select where to insert the new entry:"
      ############################################################################
      DIALOG_SINGLE_SELECT "${TITLEBAR}" "${BAKTITLE}" 'hidetags' '' \
        "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' || return 1
      SELECTED="$(</tmp/selection)"

      if [[ ${SELECTED} -lt ${SUGGESTS[-1]} ]]; then
        EXSTANZA="$(GET_STANZA_SYSLINUX "${ASTANZAS[${SELECTED}]}" "${CFG_FILE}")"
        EXSTANZA="${EXSTANZA//\\/\\\\}"
        EXSTANZA="${EXSTANZA//$'\n'/\\n}"
        EXSTANZA="${EXSTANZA//$'\t'/\\t}"
        USE_PRIVILEGE "${BIN[sed]}" -i ':a;N;$!ba;'"s|${EXSTANZA}|${BTSTANZA}\n\n${EXSTANZA}|g" "${CFG_FILE}"
      else
        EXSTANZA="$(GET_STANZA_SYSLINUX "${ASTANZAS[$((SELECTED-1))]}" "${CFG_FILE}")"
        EXSTANZA="${EXSTANZA//\\/\\\\}"
        EXSTANZA="${EXSTANZA//$'\n'/\\n}"
        EXSTANZA="${EXSTANZA//$'\t'/\\t}"
        USE_PRIVILEGE "${BIN[sed]}" -i ':a;N;$!ba;'"s|${EXSTANZA}|${EXSTANZA}\n\n${BTSTANZA}|g" "${CFG_FILE}"
      fi

    else
      EXSTANZA="$(GET_STANZA_SYSLINUX "${DESCRIPS[${SELECTED}]}" "${CFG_FILE}")"
      EXSTANZA="${EXSTANZA//\\/\\\\}"
      EXSTANZA="${EXSTANZA//$'\n'/\\n}"
      EXSTANZA="${EXSTANZA//$'\t'/\\t}"
      USE_PRIVILEGE "${BIN[sed]}" -i ':a;N;$!ba;'"s|${EXSTANZA}|${BTSTANZA}|g" "${CFG_FILE}"
    fi
  else
    USE_PRIVILEGE sh -c "'${BIN[printf]}' '|%b||' '${BTSTANZA}' | tr '|' '\n' >> '${CFG_FILE}'"
  fi
}

function GENERATE_BOOT_STANZA_SYSTEMD_BOOT {
  [[ -n "${1}" ]] && local ADDLKCLP="${1}" || unset ADDLKCLP
  [[ -n "${2}" ]] && local PLYMKCLP="${2}" || unset PLYMKCLP
  [[ -n "${3}" ]] && local LUKSKCLP="${3}" || unset LUKSKCLP
  local CFG_FILE BAKTITLE HELP_MSG SELECTED BTSTANZA EXSTANZA STNZATTL
  local -a ASTANZAS SUGGESTS DESCRIPS DISP_MGR SAME_IRD
  local -i LC

  CNFG_DIR="${LDR_MTPT}/loader/entries"
  DISP_MGR="${OSCHROOT}/etc/systemd/system/display-manager.service"
  [[ ${MIR_IMGS[${LC}]} == "${RIR_IMGS[${LC}]}" ]] && SAME_IRD=true || SAME_IRD=false

  for (( LC=0 ; LC<${#KRN_IMGS[@]} ; LC++ )); do
    for CFG_TYPE in common gabby nogui oops rescue; do
      [[ ! -e ${DISP_MGR} ]] && [[ ${CFG_TYPE} == nogui ]] && continue
      [[ ! ${ADDLKCLP} =~ quiet ]] && [[ ${CFG_TYPE} == verbose ]] && continue
      [[ -z ${RIR_IMGS[${LC}]} ]] || [[ ${CFG_TYPE} == oops ]] && ${SAME_IRD} && continue
      case "${CFG_TYPE}" in
        common) TCFGTYPE="Normal";;
         gabby) [[ -z ${PLMTHKCL} ]] && TCFGTYPE="Verbose" || TCFGTYPE="No Splash & Verbose";;
         nogui) TCFGTYPE="CLI";;
          oops) TCFGTYPE="Fallback";;
        rescue) TCFGTYPE="Rescue";;
      esac
      BTSTANZA="title\t${OSR_NAME}${OSR_VRSN+ }${OSR_VRSN}${KRNTYPES[${LC}]+ }${KRNTYPES[${LC}]^} ${TCFGTYPE}\n"
      BTSTANZA+="linux\t${KRN_IMGS[${LC}]}\n"
      [[ -n ${MCODEIRD} ]] && BTSTANZA+="${MCODEIRD}\n"
      case "${CFG_TYPE}" in
        common|gabby|nogui)
          [[ -n ${MIR_IMGS[${LC}]} ]] && BTSTANZA+="initrd\t${MIR_IMGS[${LC}]}\n";;
        oops|rescue)
          [[ -n ${RIR_IMGS[${LC}]} ]] && BTSTANZA+="initrd\t${RIR_IMGS[${LC}]}\n";;
      esac
      case "${CFG_TYPE}" in
        common)
          BTSTANZA+="options\t${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP}${LUKSKCLP+ }${LUKSKCLP}${PLYMKCLP+ }${PLYMKCLP}\n";;
        gabby|oops)
          BTSTANZA+="options\t${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / }${LUKSKCLP+ }${LUKSKCLP}\n";;
        nogui)
          BTSTANZA+="options\t${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / }${LUKSKCLP+ }${LUKSKCLP} systemd.unit=multi-user.target\n";;
        rescue)
          BTSTANZA+="options\t${RFS_SPEC}${RFS_FLGS+ }${RFS_FLGS} ${ADDLKCLP/ quiet / }${LUKSKCLP+ }${LUKSKCLP} systemd.unit=rescue.target\n";;
      esac
      USE_PRIVILEGE sh -c "'${BIN[printf]}' '%b\n' '${BTSTANZA}' > '${CNFG_DIR}/${OSR_OSID}-${KRNTYPES[${LC}],,}-${CFG_TYPE}.conf'"
    done
  done

  if [[ -e ${LDR_MTPT}/EFI/tools/fwupdx64.efi ]]; then
    BTSTANZA="title\tFirmware Update\n"
    BTSTANZA+="efi\t/EFI/tools/fwupdx64.efi\n"
    USE_PRIVILEGE sh -c "'${BIN[printf]}' '%b\n' '${BTSTANZA}' > '${CNFG_DIR}/zzzz-fwupdate.conf'"
  fi

  if [[ -e ${LDR_MTPT}/EFI/memtest86/memtest86.efi ]]; then
    BTSTANZA="title\tMemTest86\n"
    BTSTANZA+="efi\t/EFI/memtest86/memtest86.efi"
    USE_PRIVILEGE sh -c "'${BIN[printf]}' '%b\n' '${BTSTANZA}' > '${CNFG_DIR}/zzzz-memtest86.conf'"
  elif [[ -e ${LDR_MTPT}/EFI/tools/memtest86.efi ]]; then
    BTSTANZA="title\tMemTest86\n"
    BTSTANZA+="efi\t/EFI/tools/memtest86.efi"
    USE_PRIVILEGE sh -c "'${BIN[printf]}' '%b\n' '${BTSTANZA}' > '${CNFG_DIR}/zzzz-memtest86.conf'"
  fi
}

function INSTALL_EFI_BOOT_ENTRY {
  local EFI_PATH BT_LABEL CURRENT
  case "${SYSTEM[cpu-arch]}" in
    *86)
      case "${SYSTEM[fw-bits]}" in
        64) SUFFIX='x64';;
        32) SUFFIX='ia32';;
      esac
      ;;
  esac

  case "${1}" in
    grub)
      EFI_PATH="/EFI/grub/grub${SUFFIX}.efi"
      BT_LABEL='GRUB'
      ;;
    refind)
      EFI_PATH="/EFI/refind/refind_${SUFFIX}.efi"
      BT_LABEL='rEFInd Boot Manager'
      ;;
    syslinux)
      EFI_PATH="/EFI/syslinux/syslinux.efi"
      BT_LABEL='SysLinux'
      ;;
    systemd-boot)
      EFI_PATH="/EFI/systemd/systemd-boot${SUFFIX}.efi"
      BT_LABEL='Linux Boot Manager'
      ;;
  esac

  CURRENT="$("${BIN[efibootmgr]}" -v)"

  shopt -s nocasematch
  if ! [[ ${CURRENT} =~ ${BT_LABEL}.*${LDR_UUID}.*${EFI_PATH//\//\\\\} ]]; then
    USE_PRIVILEGE "${BIN[efibootmgr]}" --quiet --create --disk "${LDR_DISK}" --part "${LDR_PNUM}" --loader "${EFI_PATH}" --label "${BT_LABEL}"
  fi
  shopt -u nocasematch
}

function INSTALL_EFI_TOOLS {
  if [[ -e ${OSCHROOT}/usr/share/edk2-shell ]]; then
    USE_PRIVILEGE "${BIN[cp]}" -up "${OSCHROOT}/usr/share/edk2-shell/ia32/Shell_Full.efi" "${LDR_MTPT}/EFI/shellia32.efi"
    USE_PRIVILEGE "${BIN[cp]}" -up "${OSCHROOT}/usr/share/edk2-shell/x64/Shell_Full.efi" "${LDR_MTPT}/EFI/shellx64.efi"
  elif  [[ -e ${OSCHROOT}/usr/uefi/edk2-shell ]]; then
    USE_PRIVILEGE "${BIN[cp]}" -up "${OSCHROOT}/usr/share/uefi-shell/shellia32_v2.efi" "${LDR_MTPT}/EFI/shellia32.efi"
    USE_PRIVILEGE "${BIN[cp]}" -up "${OSCHROOT}/usr/share/uefi-shell/shellx64_v2.efi" "${LDR_MTPT}/EFI/shellx64.efi"
  fi
  if [[ -e ${OSCHROOT}/usr/lib/fwupd/efi/ ]]; then
    USE_PRIVILEGE "${BIN[mkdir]}" -p "${LDR_MTPT}/EFI/tools/"
    USE_PRIVILEGE "${BIN[cp]}" -up "${OSCHROOT}/usr/lib/fwupd/efi/fwupd"* "${LDR_MTPT}/EFI/tools/"
  fi
  if [[ -e ${OSCHROOT}/usr/share/memtest86-efi ]]; then
    USE_PRIVILEGE "${BIN[mkdir]}" -p "${LDR_MTPT}/EFI/tools/"
    USE_PRIVILEGE "${BIN[cp]}" -up "${OSCHROOT}/usr/share/memtest86-efi/"*.* "${LDR_MTPT}/EFI/tools/"
  fi
}

function INSTALL_HOOK_REFIND {
  if ! [[ -e ${OSCHROOT}/etc/pacman.d/hooks/refind.hook ]]; then
    USE_PRIVILEGE "${BIN[mkdir]}" -p "${OSCHROOT}/etc/pacman.d/hooks"
    USE_PRIVILEGE sh -c "'${BIN[cat]}' <<- ENDOFSCRIPT > ${OSCHROOT}/etc/pacman.d/hooks/refind.hook
		[Trigger]
		Type=Package
		Operation=Upgrade
		Target=systemd

		[Action]
		Description=Updating systemd-boot
		When=PostTransaction
		Exec=/usr/bin/bootctl update
		ENDOFSCRIPT"
  fi
}

function INSTALL_HOOK_SYSTEMDBOOT {
  if ! [[ -e ${OSCHROOT}/etc/pacman.d/hooks/100-systemd-boot.hook ]]; then
    USE_PRIVILEGE "${BIN[mkdir]}" -p "${OSCHROOT}/etc/pacman.d/hooks"
    USE_PRIVILEGE sh -c "'${BIN[cat]}' <<- ENDOFSCRIPT > ${OSCHROOT}/etc/pacman.d/hooks/100-systemd-boot.hook
		[Trigger]
		Operation=Upgrade
		Type=Package
		Target=refind
		
		[Action]
		Description=Updating rEFInd on ESP
		When=PostTransaction
		Exec=/usr/bin/refind-install
		ENDOFSCRIPT"
  fi
}

function INSTALL_GRUB {
  local LDR_PATH LDR_ULIB LOCATION USINGMBR
  if [[ ${VALIDEFI+y} == y ]]; then
    LDR_PATH="${LDR_MTPT}/EFI/grub"
    CHOOSE_EFI_STANDARD_OR_DEFAULT "${LDR_PATH}"
    LOCATION="$(</tmp/selection)"
  else
    LDR_PATH="${LDR_MTPT}${LDR_BPTH}/grub"
    LOCATION="${LDR_MTPT}${LDR_BPTH}/grub"
  fi
  LDR_ULIB="${OSCHROOT}/usr/lib/grub"
  LDR_USHR="${OSCHROOT}/usr/share/grub"

  USE_PRIVILEGE "${BIN[mkdir]}" -p "${LDR_MTPT}${LDR_BPTH}/grub" \
    "${LDR_PATH//\/EFI/}"/{fonts,locale,themes/starfield,i386-pc,i386-efi,x86_64-efi}

  USE_PRIVILEGE "${BIN[cp]}" -up "${LDR_USHR}/"*.pf2 "${LDR_PATH//\/EFI/}/fonts"
  USE_PRIVILEGE "${BIN[cp]}" -up "${LDR_USHR}/themes/starfield/"* "${LDR_PATH//\/EFI/}/themes/starfield"

  while read -r LOCALE; do
    SHRTNAME="${LOCALE##*locale/}"
    SHRTNAME="${SHRTNAME%%/*}"
    USE_PRIVILEGE "${BIN[cp]}" -up "${LOCALE}" "${LDR_PATH//\/EFI/}/locale/${SHRTNAME}.mo"
  done < <("${BIN[find]}" "${OSCHROOT}/usr/share/locale" -name 'grub.mo')

  for PLATFORM in x64:x86_64-efi ia32:i386-efi ia32:i386-pc; do
    [[ ${PLATFORM} == ia32:i386-pc ]] && USINGMBR='yes' || unset USINGMBR
    USE_PRIVILEGE "${BIN[cp]}" -up "${LDR_ULIB}/${PLATFORM#*:}/"*.mod "${LDR_PATH//\/EFI/}/${PLATFORM#*:}/"
    USE_PRIVILEGE  "${OSCHROOT}/usr/bin/grub-mkimage" --verbose --directory "${LDR_ULIB}/${PLATFORM#*:}" \
      --prefix "(,${LDR_PTYP}${LDR_PNUM})/grub" --output "${LDR_PATH//\/EFI/}/${PLATFORM#*:}/core.efi" \
      --format ${PLATFORM#*:} --compression 'auto' 'fat' "part_${LDR_PTYP}" ${USINGMBR+biosdisk}
    if [[ ${PLATFORM} == ia32:i386-pc ]]; then
      USE_PRIVILEGE "${BIN[mv]}" "${LDR_PATH//\/EFI/}/${PLATFORM#*:}/core.efi" "${LDR_PATH//\/EFI/}/${PLATFORM#*:}/core.img"
      USE_PRIVILEGE "${BIN[cp]}" -up "${LDR_ULIB}/${PLATFORM#*:}/boot.img" "${LDR_PATH//\/EFI/}/${PLATFORM#*:}/"
      if [[ ${LDR_PTYP} == msdos ]]; then
        USE_PRIVILEGE "${OSCHROOT}/usr/bin/grub-bios-setup" --verbose --directory="${LDR_PATH//\/EFI/}/${PLATFORM#*:}" \
          --device-map="${LDR_PATH//\/EFI/}/device.map" "${LDR_DISK}"
      fi
    else
      USE_PRIVILEGE "${OSCHROOT}/usr/bin/grub-mkimage" --verbose --directory "${LDR_ULIB}/${PLATFORM#*:}" \
         --output "${LDR_PATH//\/EFI/}/${PLATFORM#*:}/grub.efi" \
         --format "${PLATFORM#*:}" --compression 'auto' 'fat' "part_${LDR_PTYP}"
    fi
    [[ ${LOCATION} =~ /EFI/Boot ]] && OUTPUTFN="boot${PLATFORM%:*}.efi" || unset OUTPUTFN
    [[ ${LDR_PTYP} == gpt ]] && USE_PRIVILEGE "${BIN[cp]}" -up \
      "${LDR_PATH//\/EFI/}/${PLATFORM#*:}/core.efi" "${LOCATION}/${OUTPUTFN}"
  done

  [[ ${LOCATION} =~ /EFI/Boot ]] || [[ ${VALIDEFI+y} != y ]] || INSTALL_EFI_BOOT_ENTRY grub
}

function INSTALL_REFIND {
  local LDR_PATH="${LDR_MTPT}/EFI/refind"
  local LDR_USHR="/usr/share/refind"
  local LOCATION OUTPUTFN FW

  CHOOSE_EFI_STANDARD_OR_DEFAULT "${LDR_PATH}"
  LOCATION="$(</tmp/selection)"

  USE_PRIVILEGE "${BIN[mkdir]}" -p "${LDR_MTPT}"/EFI/{Boot,refind/icons/svg,refind/fonts}

  for FW in x64 ia32; do
    if [[ -e ${OSCHROOT}${LDR_USHR}/drivers_${FW} ]]; then
      USE_PRIVILEGE "${BIN[mkdir]}" -p "${LDR_PATH}/drivers_${FW}"
      USE_PRIVILEGE "${BIN[cp]}" -up "${OSCHROOT}${LDR_USHR}/drivers_${FW}/"* "${LDR_PATH}/drivers_${FW}/"
    fi
    if [[ -e ${OSCHROOT}${LDR_USHR}/refind_${FW}.efi ]]; then
      [[ ${LOCATION} =~ /EFI/Boot ]] && OUTPUTFN="boot${FW}.efi" || unset OUTPUTFN
      USE_PRIVILEGE "${BIN[cp]}" -up "${OSCHROOT}${LDR_USHR}/refind_${FW}.efi" "${LOCATION}/${OUTPUTFN}"
    fi
  done

  USE_PRIVILEGE "${BIN[cp]}" -np "${OSCHROOT}${LDR_USHR}/refind.conf-sample" "${LDR_PATH}/refind.conf"
  USE_PRIVILEGE "${BIN[cp]}" -np "${OSCHROOT}${LDR_USHR}/icons/svg/"* "${LDR_PATH}/icons/svg"
  USE_PRIVILEGE "${BIN[cp]}" -np "${OSCHROOT}${LDR_USHR}/icons/"* "${LDR_PATH}/icons/"
  USE_PRIVILEGE "${BIN[cp]}" -np "${OSCHROOT}${LDR_USHR}/fonts/"* "${LDR_PATH}/fonts/"

  [[ ${LOCATION} =~ /EFI/Boot ]] || INSTALL_EFI_BOOT_ENTRY refind
}

function INSTALL_SYSLINUX {
  local LDR_ARCH LDR_PATH LDR_ULIB LOCATION
  if [[ ${VALIDEFI+y} == y ]]; then
    LDR_PATH="${LDR_MTPT}/EFI/syslinux"
    CHOOSE_EFI_STANDARD_OR_DEFAULT "${LDR_PATH}"
    LOCATION="$(</tmp/selection)"
  else
    LDR_PATH="${LDR_MTPT}${LDR_BPTH}/syslinux"
    LOCATION="${LDR_MTPT}${LDR_BPTH}/syslinux"
  fi
  LDR_ULIB="${OSCHROOT}/usr/lib/syslinux"

  USE_PRIVILEGE "${BIN[mkdir]}" -p "${LDR_PATH}"

  # Syslinux has a bit of a problem in that you can't copy both x64 and
  # ia32 files over.  It expects c32 files to be in /EFI/syslinux and
  # there's no difference in name between the two architectures.

  if [[ -e ${LDR_ULIB}/efi${SYSTEM[fw-bits]} ]]; then
    [[ ${SYSTEM[fw-bits]} -eq 64 ]] && LDR_ARCH='x64' || LDR_ARCH='ia32'
    USE_PRIVILEGE "${BIN[cp]}" -up "${LDR_ULIB}/efi${SYSTEM[fw-bits]}/"*.c32 "${LDR_PATH}/"
    [[ ${LOCATION} =~ /EFI/Boot ]] && OUTPUTFN="boot${LDR_ARCH}.efi" || unset OUTPUTFN
    USE_PRIVILEGE "${BIN[cp]}" -up "${LDR_ULIB}/efi${SYSTEM[fw-bits]}/syslinux.efi" "${LOCATION}/${OUTPUTFN}"
  fi

  if [[ ${LOCATION} =~ /EFI ]]; then
    USE_PRIVILEGE "${BIN[cp]}" -np "${IMG_PATH}/syslinux/syslinux.cfg" "${LDR_PATH}/syslinux.cfg"
    [[ ${LOCATION} =~ /EFI/Boot ]] || INSTALL_EFI_BOOT_ENTRY syslinux
  else
   USE_PRIVILEGE "${BIN[dd]}" bs=440 count=1 conv=notrunc if="${LDR_ULIB}/bios/mbr.bin" of="${LDR_DISK}"
  fi
}

function INSTALL_SYSTEMD_BOOT {
  local LDR_PATH="${LDR_MTPT}/EFI/systemd"
  local LDR_ULIB="${OSCHROOT}/usr/lib/systemd/boot/efi"

  CHOOSE_EFI_STANDARD_OR_DEFAULT "${LDR_PATH}"
  LOCATION="$(</tmp/selection)"

  USE_PRIVILEGE "${BIN[mkdir]}" -p "${LDR_MTPT}"/EFI/{Boot,Linux,systemd} \
    "${LDR_MTPT}"/loader/entries

  for FW in x64 ia32; do
    if [[ -e ${LDR_ULIB}/systemd-boot${FW}.efi ]]; then
      [[ ${LOCATION} =~ /EFI/Boot ]] && OUTPUTFN="boot${FW}.efi" || unset OUTPUTFN
      USE_PRIVILEGE "${BIN[cp]}" -up "${LDR_ULIB}/systemd-boot${FW}.efi" "${LOCATION}/${OUTPUTFN}"
    fi
  done

  [[ -e "${LDR_MTPT}/loader/random-seed" ]] || \
    USE_PRIVILEGE "${BIN[dd]}" if=/dev/random of="${LDR_MTPT}/loader/random-seed" bs=512 count=1 > /dev/null 2>&1

  [[ ${LOCATION} =~ /EFI/Boot ]] || INSTALL_EFI_BOOT_ENTRY refind
}

function SELECT_BOOTLOADER {
  #######################################################################
  local -r BAKTITLE="Bootloader Selection"
  local -r HELP_MSG="Select the boot loader to configure and install:"
  #######################################################################
  local -a SUGGESTS DESCRIPS

  if [[ -e ${OSCHROOT}/usr/sbin/grub-mkconfig ]]; then
    SUGGESTS+=(grub2)
    DESCRIPS+=('GNU GRand Unified Bootloader 2')
  fi; if [[ -e ${OSCHROOT}/usr/sbin/refind-install ]]; then
    SUGGESTS+=(refind)
    DESCRIPS+=('An EFI boot manager forked from rEFIt')
  fi; if [[ -e ${OSCHROOT}/usr/bin/syslinux ]]; then
    if [[ ${IMG_UUID} == ${LDR_UUID} ]]; then
      SUGGESTS+=(syslinux)
      DESCRIPS+=('Suite of lightweight boot loaders')
    fi
  fi; if [[ -e ${OSCHROOT}/usr/bin/bootctl ]]; then
    SUGGESTS+=(systemd-boot)
    DESCRIPS+=('An EFI boot loader included with systemd')
  fi

  DIALOG_SINGLE_SELECT "${TITLEBAR}" "${BAKTITLE}" 'showtags' '' \
    "${HELP_MSG}" 'SUGGESTS' 'DESCRIPS' 'Exit' || return 1
}

################################################################################
# EFI SYSTEM PARTITION INFO DISCOVERY
################################################################################

ESPPARTS="$("${BIN[lsblk]}" -lno NAME,PARTTYPE | "${BIN[grep]}" "${ESP_GUID}\|0xef" | \
    "${BIN[cut]}" -d\  -f1 | "${BIN[paste]}" -d\  -s | ${BIN[sed]} 's/ /\\|/g')"

# We should now have a string with '\|' between candidates

if [[ -n ${ESPPARTS} ]]; then
  # Parse the mounts output for block devices we've found to be EFI System Partitions
  # Limit the output to the OSCHROOT we are working from
  LDR_MTPT="$("${BIN[mount]}" | "${BIN[grep]}" "${ESPPARTS}" | \
    "${BIN[grep]}" "${OSCHROOT}" | "${BIN[cut]}" -d\  -f3 | "${BIN[paste]}" -d\  -s)"
  # If we've found more than one, fail for now.  In the future, prompt the user.
  [[ ${LDR_MTPT} =~ [[:blank:]] ]] && echo 'Multiple ESP mount points found.' && exit 1
  # Get the block device behind the mount point
  LDR_BDEV="$("${BIN[mount]}" | "${BIN[grep]}" "on ${LDR_MTPT} type" | "${BIN[cut]}" -d\  -f1)"
  # Set the VALIDEFI variable.  It doesn't matter what, just that it's set.
  VALIDEFI='set'
fi

# At this point, if LDR_MTPT is unset than we've failed to find an appropriate EFI
# System Partition device.  Now we assume BIOS+MBR is being used.

################################################################################
# BIOS+MBR INFO DISCOVERY
################################################################################

if [[ -z ${LDR_MTPT} ]]; then
  # Make sure VALIDEFI is unset, not just an empty string.  THIS IS IMPORTANT LATER!
  unset VALIDEFI
  # Since we can't rely on an EFI System Partition type anymore, assume /boot is
  # where things are at and see if it's a mount point.
  LDR_BDEV="$("${BIN[mount]}" | "${BIN[grep]}" "on ${OSCHROOT}/boot type" | "${BIN[cut]}" -d\  -f1)"
  # This refers to how the boot loader will see the path of the images
  LDR_BPTH="/"
  LDR_MTPT="${OSCHROOT}/boot"
  # If that didn't do the trick, get the root filesystem's block device.
  if [[ -z ${LDR_BDEV} ]]; then
    LDR_BDEV="$("${BIN[mount]}" | "${BIN[grep]}" "on ${OSCHROOT} type" | "${BIN[cut]}" -d\  -f1)"
    # The loader will see the images in /boot now
    LDR_BPTH="/boot"
    LDR_MTPT="${OSCHROOT}"
  fi
fi

################################################################################
# LOADER INFORMATION
################################################################################

LDR_DISK="/dev/$("${BIN[lsblk]}" -lno NAME,PKNAME | "${BIN[grep]}" "${LDR_BDEV##*/}" | "${BIN[sed]}" 's/.* //g')"
LDR_PNUM="${LDR_BDEV##${LDR_DISK}}"; LDR_PNUM="${LDR_PNUM#p}"
LDR_PTYP="$(${BIN[lsblk]} -lno NAME,PTTYPE | "${BIN[grep]}" "${LDR_BDEV##*/}" | "${BIN[sed]}" 's/.* //g')"
LDR_PTYP="${LDR_PTYP/dos/msdos}"
LDR_UUID="$("${BIN[lsblk]}" -lno NAME,PARTUUID | "${BIN[grep]}" "${LDR_BDEV##*/}" | "${BIN[sed]}" 's/.* //g')"
LDR_PLBL="$("${BIN[lsblk]}" -lno NAME,PARTLABEL | "${BIN[grep]}" "${LDR_BDEV##*/}" | "${BIN[sed]}" 's/.* //g')"

################################################################################
# IMAGE LOCATION INFORMATION (kernels and initrds)
################################################################################

while true; do
  ((LC++))
  IMG_PATH="$("${BIN[find]}" "${OSCHROOT:-/}" -maxdepth "${LC}" -name 'vmlinuz*' 2> /dev/null | "${BIN[sort]}" | "${BIN[head]}" -1 | "${BIN[sed]}" 's|/vmlinuz.*||g')"
  [[ -n ${IMG_PATH} ]] && break
done

# Now we have to descronstuct the path so we can find the mount point
PTHPARTS="$(echo "${IMG_PATH}" | "${BIN[tr]}" -dc '/' | "${BIN[wc]}" -c)"
((PTHPARTS++))

# Walk backwards through the path
for (( LC=PTHPARTS ; LC>0 ; LC-- )); do
  PTHMOUNT="$(echo "${IMG_PATH}" | "${BIN[cut]}" -d/ -f1-"${LC}")"
  IMG_BDEV="$("${BIN[mount]}" | "${BIN[grep]}" "on ${PTHMOUNT} type" | "${BIN[cut]}" -d\  -f1)"
  [[ -n ${IMG_BDEV} ]] && IMG_MTPT="${PTHMOUNT}" && break
done

# Now that we have IMG_MTPT, IMG_BDEV, and IMG_PATH like we did for LDR_*
# it's time to get the rest.
IMG_DISK="/dev/$("${BIN[lsblk]}" -lno NAME,PKNAME | "${BIN[grep]}" "${IMG_BDEV##*/}" | "${BIN[sed]}" 's/.* //g')"
IMG_PNUM="${IMG_BDEV##${LDR_DISK}}"; IMG_PNUM="${IMG_PNUM#p}"
IMG_PTYP="$(${BIN[lsblk]} -lno NAME,PTTYPE | "${BIN[grep]}" "${IMG_BDEV##*/}" | "${BIN[sed]}" 's/.* //g')"
IMG_PTYP="${IMG_PTYP/dos/msdos}"
IMG_UUID="$("${BIN[lsblk]}" -lno NAME,PARTUUID | "${BIN[grep]}" "${IMG_BDEV##*/}" | "${BIN[sed]}" 's/.* //g')"
IMG_PLBL="$("${BIN[lsblk]}" -lno NAME,PARTLABEL | "${BIN[grep]}" "${IMG_BDEV##*/}" | "${BIN[sed]}" 's/.* //g')"
IMG_SBVL="$("${BIN[mount]}" | "${BIN[grep]}" "on ${IMG_MTPT} type" | "${BIN[grep]}" subvol | "${BIN[sed]}" 's/.*subvol=\(.*\),.*/\1/g')"
IMG_BPTH="${IMG_SBVL}${IMG_PATH#${IMG_MTPT}}"

################################################################################
# KERNEL AND INITRAMFS ENUMERATION
################################################################################

for FULLPATH in "${IMG_PATH}"/vmlinuz-linux*; do
  KRNTYPES+=("${FULLPATH#*vmlinuz-linux}")
  KRNTYPES[-1]="${KRNTYPES[-1]#-}"
  KRNTYPES[-1]="${KRNTYPES[-1]/lts/LTS}"
  KRN_IMGS+=("${IMG_BPTH}${FULLPATH#${IMG_PATH}}")
  if [[ -e ${FULLPATH/vmlinuz/initramfs}.img ]]; then
    MIRD_IMG="${KRN_IMGS[-1]/vmlinuz/initramfs}.img"
  fi; if [[ -e ${FULLPATH/vmlinuz/initramfs}-fallback.img ]]; then
    RIRD_IMG="${KRN_IMGS[-1]/vmlinuz/initramfs}-fallback.img"
    [[ -z ${MIRD_IMG} ]] && MIRD_IMG="${RIRD_IMG}"
  fi
  [[ -z ${RIRD_IMG} ]] && RIRD_IMG="${MIRD_IMG}"
  MIR_IMGS+=("${MIRD_IMG}")
  RIR_IMGS+=("${RIRD_IMG}")
done

################################################################################
# CPU MICROCODE DISCOVERY
################################################################################

for CPUMCODE in amd-ucode.img intel-ucode.img; do
  [[ -e ${IMG_PATH}/${CPUMCODE} ]] && MCODEIRD+="${IMG_BPTH}/${CPUMCODE} "
done
[[ -n ${MCODEIRD} ]] && MCODEIRD="${MCODEIRD% }"

################################################################################
# ROOT FILESYSTEM INFORMATION
################################################################################

RFS_TYPE="$("${BIN[mount]}" | "${BIN[grep]}" "on ${OSCHROOT:-/} type" | "${BIN[cut]}" -d\  -f5)"
RFS_BDEV="$("${BIN[mount]}" | "${BIN[grep]}" "on ${OSCHROOT:-/} type ${RFS_TYPE}" | "${BIN[cut]}" -d\  -f1)"
if [[ ${RFS_TYPE} == zfs ]]; then
  RFS_SPEC="zfs=${RFS_BDEV}"
else
  RFS_UUID="$("${BIN[lsblk]}" -lno NAME,UUID | "${BIN[grep]}" "${RFS_BDEV##*/}" | "${BIN[sed]}" 's/.* //g')"
  RFS_FLBL="$("${BIN[lsblk]}" -lno NAME,LABEL | "${BIN[grep]}" "${RFS_BDEV##*/}" | "${BIN[sed]}" 's/.* //g')"
  if [[ -n ${RFS_FLBL} ]]; then
    RFS_SPEC="root=LABEL=${RFS_FLBL}"
  elif [[ -n ${RFS_UUID} ]]; then
    RFS_SPEC="root=UUID=${RFS_UUID}"
  else
    RFS_SPEC="root=${RFS_BDEV}"
  fi
  RFS_FLGS="rootflags=$("${BIN[mount]}" | "${BIN[grep]}" "on ${OSCHROOT:-/} type" | \
    "${BIN[sed]}" 's/.*(\(.*\))/\1/g' | "${BIN[sed]}" "s/$(DEFAULT_MOUNT_OPTIONS)//g;s/,$//g")"
fi

################################################################################
# OS-RELEASE INFORMATION
################################################################################

OSR_NAME="$("${BIN[grep]}" '^NAME=' "${OSCHROOT}/etc/os-release" | "${BIN[cut]}" -d= -f2 | "${BIN[tr]}" -d '"' )"
OSR_VRSN="$("${BIN[grep]}" '^VERSION=' "${OSCHROOT}/etc/os-release" | "${BIN[cut]}" -d= -f2 | "${BIN[tr]}" -d '"' )"
OSR_OSID="$("${BIN[grep]}" '^ID=' "${OSCHROOT}/etc/os-release" | "${BIN[cut]}" -d= -f2 | "${BIN[tr]}" -d '"' )"
[[ -z ${OS_VRSN} ]] && OSR_VRSN="$("${BIN[grep]}" '^VERSION_ID=' "${OSCHROOT}/usr/lib/os-release" | "${BIN[cut]}" -d= -f2 | "${BIN[tr]}" -d '"' )"
[[ -z ${OS_VRSN} ]] && unset OSR_VRSN
[[ ${OSR_OSID} =~ '-' ]] && OSR_OSID="${OSR_OSID%-*}"

# This is a useful debugging line to see what all the discovery found
# set | grep '^IMG\|^KRN\|^LDR\|^MCO\|^OSR\|^RFS'; exit 0

while true; do
  SELECT_BOOTLOADER || break
  case "$(</tmp/selection)" in
    grub2)
      INSTALL_GRUB && \
      INSTALL_EFI_TOOLS
      DIALOG_MSGBOX "${TITLEBAR}" 'GRUB 2' 'GRUB 2 and EFI tools have been installed, but no further functionality exists yet.'
      ;;
    refind)
      INSTALL_REFIND && \
      INSTALL_EFI_TOOLS && \
      INSTALL_HOOK_REFIND && \
      GENERATE_BOOT_STANZA refind && \
      CONFIGURE_REFIND
      ;;
    syslinux)
      INSTALL_SYSLINUX && \
      MANAGE_SYSLINUX_TOOLS && \
      GENERATE_BOOT_STANZA syslinux && \
      CONFIGURE_SYSLINUX
      ;;
    systemd-boot)
      INSTALL_SYSTEMD_BOOT && \
      INSTALL_EFI_TOOLS && \
      INSTALL_HOOK_SYSTEMDBOOT && \
      GENERATE_BOOT_STANZA systemd-boot && \
      CONFIGURE_SYSTEMD_BOOT
      ;;
  esac
done

exit 0
